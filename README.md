### 时间复杂度 执行算法所需时间

`T(n) = O(f(n))`
`n`变化因子 `f(n)`具体算法
`O`表示法 并非代表算法真正执行时间 而是表示代码执行时间增长变化趋势
***
常见时间复杂度量级
+ 常数阶O(1)
```c
int a = 1;
int b = 2;
```
执行一次代码消耗1个时间单位 执行两次代码消耗两个时间单位
当算法并无伴随某变量增长而变化时 无论执行几次 时间复杂度一直为O(1)
+ 线性阶O(n)
```c
for(i = 0; i < n; i++) {
    j = i;
    j++;
}
```
第1行会执行1次 第2行和第3行会分别执行n次 共执行`2n + 1`次 时间复杂度为O(n)
+ 对数阶O(logN)
```c
int i = 1;
while(i < n) {
    i *=  2;
}
```
每次循环i会乘2 共循环`log2n + 2`次 时间复杂度为O(logn)
+ 线性对数阶O(nlogN)
```c
for (m = 1; m < n; m++) {
    i = 1;
    while (i < n) {
        i *= 2;
    }
}
```
`O(logn)`循环N遍 `n * O(logN)` 时间复杂度为O(nlogN)
+ 平方阶O(n²)
```c
for (x = 1; i <= n; x++) {
    for (i = 1; i <= n; i++) {
        j = i;
        j++;
    }
}
```
O(n)再嵌套循环一层 时间复杂度为O(n²)
+ 立方阶O(n³)
+ 指数阶(2^n)
+ K次方阶O(n^k)
立方阶O(n³) K次方阶O(n^k) 参考O(n²) O(n³)为三层n循环
***
### 空间复杂度 执行算法所需空间

`S(n)=O(f(n))`
`n`变化因子 `f(n)`具体算法
`S`表示法 并非代表算法真正所需空间 而是表示代码所需空间增长变化趋势
***
算法执行所需临时空间不随变量改变而改变 空间复杂度为`O(1)`

其余类似时间复杂度
***
常用排序算法时间复杂度和空间复杂度
名称|时间复杂度平均|空间复杂度

排序方法|时间复杂度(平均)|时间复杂度(最坏)|时间复杂度(最好)|空间复杂度|稳定性|复杂性
-|-|-|-|-|-|-
直接插入排序|O(n2)|O(n2)|O(n)|O(1)|稳定|简单
希尔排序|O(nlog2n)|O(n2)|O(n1.3)|O(1)|不稳定|较复杂
直接选择排序|O(n2)|O(n2)|O(n2)|O(1)|不稳定|简单
堆排序|O(nlog2n)|O(nlog2n)|O(nlog2n)|O(1)|不稳定|较复杂
冒泡排序|O(n2)|O(n2)|O(n)|O(1)|稳定|简单
快速排序|O(nlog2n)|O(n2)|O(nlog2n)|O(nlog2n)|不稳定|较复杂
归并排序|O(nlog2n)|O(nlog2n)|O(nlog2n)|O(n)|稳定|较复杂
基数排序|O(d(n+r))|O(d(n+r))|O(d(n+r))|O(n+r)|稳定|较复杂