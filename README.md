### 时间复杂度 执行算法所需时间

`T(n) = O(f(n))`
`n`变化因子 `f(n)`具体算法
`O`表示法 并非代表算法真正执行时间 而是表示代码执行时间增长变化趋势
***
常见时间复杂度量级
+ 常数阶O(1)
```c
int a;
a = 1;
```
执行一次代码消耗1个时间单位 执行两次代码消耗两个时间单位
当算法并无伴随某变量增长而变化时 无论执行几次 时间复杂度一直为O(1)
+ 线性阶O(n)
```c
int j;
for(int i = 0; i < n; i++) {
    j = i;
}
```
第1行会执行1次 第2行和第3行会分别执行n次 共执行`2n + 1`次 时间复杂度为O(n)
+ 对数阶O(log(x)n)
```c
int i = 1;
while(i < n) {
    i *=  2;
}
```
每次循环i会乘2 共循环`log₂n + 1`次 时间复杂度为O(log₂n)
+ 线性对数阶O(n * log(n))
```c
int i = 1;
for (int m = 1; m < n; m++) {
    while (i < n) {
        i *= 2;
    }
}
```
`O(logn)`循环N遍 `n * O(log₂n)` 时间复杂度为O(n log₂n)
+ 指数阶(2^n)
    + 平方阶O(n²)或O(n^2) 此处的`^`代表数学符号 程序中为亦或运算
    ```c
    int i = 0;
    int j = 0;
    int k;
    for (; i < n; i++) {
        for (; j < n; j++) {
            k = i;
        }
    }
    ```
    + 立方阶O(n³) 平方阶嵌套一层for
***
### 空间复杂度 执行算法所需空间

`S(n)=O(f(n))`
`n`变化因子 `f(n)`具体算法
`S`表示法 并非代表算法真正所需空间 而是表示代码所需空间增长变化趋势
***
算法执行所需临时空间不随变量改变而改变 空间复杂度为`O(1)`

其余类似时间复杂度
***
常用排序算法时间复杂度和空间复杂度
名称|时间复杂度平均|空间复杂度

排序方法|时间复杂度(平均)|时间复杂度(最好)|时间复杂度(最坏)|空间复杂度|稳定性|难度
-|-|-|-|-|-|-
冒泡排序|O(n²)|O(n)|O(n²)|O(1)|稳定|易
选择排序|O(n²)|O(n²)|O(n²)|O(1)|不稳定|易
插入排序|O(n²)|O(n)|O(n²)|O(1)|稳定|易
希尔排序|O(n log n)|O(n log² n)|O(n log² n)|O(1)|不稳定|难
归并排序|O(n log n)|O(n log n)|O(n log n)|O(n)|稳定|难
快速排序|O(n log n)|O(n log n)|O(n²)|O(log n)|不稳定|难
堆排序|O(n log n)|O(n log n)|O(n log n)|O(1)|不稳定|难
计数排序|O(n + k)|O(n + k)|O(n + k)|O(k)|稳定|难
桶排序|O(n + k)|O(n + k)|O(n²)|O(n + k)|稳定|难
基数排序|O(n k)|O(n k)|O(n k)|O(n + k)|稳定|难